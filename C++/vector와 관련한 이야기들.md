## vector와 관련한 이야기들



### vector와 list의 차이

- vector
  - 메모리 내에서 원소들이 연속적인 위치를 가짐
  - 랜덤 접근 가능
  - 중간 요소를 제거, 추가하는데 O(N) 시간 복잡도를 가지게 됨
- list
  - 메모리 내 흩어져 있어 비연속적 위치를 가짐
  - 위 특징으로 인해 랜덤 접근이 불가능
  - 이중 연결 리스트로 구현이 되어 있음
  - 추가, 제거를 어디서 하던 상수 시간 제거가 가능하며 



### vector의 size, capacity (feat. reserve, resize)

- size : 실제 원소들이 있는 공간
- capacity : 벡터가 차지하고 있는 공간

reserve는 여기서 capacity를 변경하는 함수이고 resize는 size를 변경하는 함수입니다.





### vector의 기본적인 동작

vector의 경우에는 연속적인 메모리 공간을 미리 할당을 하게 됩니다. 만일 원소 삽입 시 메모리 공간이 부족하다면 **새 메모리 공간을 할당한 뒤 그곳으로 기존 원소들을 복사**한 다음 새 원소를 삽입하게 됩니다.

만일 vector에서 reserve는 많이 되어 있는데 실제 사용하는 공간은 적어 메모리를 아끼고 싶다면. 새 벡터에 복사 후 맞바꾸기 하는 전략이 좋습니다.



### vector에서 값의 삭제

vector에서는 erase-remove 구문을 이용해서 제거를 하게 됩니다.

```c++
vector<> v;
//...
v.erase(remove(범위 시작, 범위 끝, 지우고 싶은 원소), v.end());
v.erase(remove_if(범위 시작, 범위 끝, 지우는 조건), v.end());
```

이 둘을 함께 사용하는 이유는 remove는 실제 삭제가 아닌 해당 조건에 부합하는 원소들을 벡터의 뒤에 넣은 뒤 '이 뒤로 밀린 원소들의 시작 범위'를 넘겨주게 됩니다.

remove 구문들이 실제로 삭제하는게 아닌 위치 변경만을 해주기 때문에 erase와 함께 사용을 하게 되는 것입니다.



### vector<bool> 

vector<bool>의 경우에는 실제 bool을 담는것이 아닌 `프록시 패턴`을 통해서 **마치 bool을 담고 있는 것처럼 동작**하게 됩니다.

실제로는 원소 한자리에 8비트의 '비트필드'를 두고 있으며 이건 vector<bool>이 유일합니다.

때문에 실제로 bool이 담긴 자료구조를 사용하고 싶다면 std::bitset이나 deque<bool>을 사용하면 됩니다.



[관련한 필자의 블로그 글](https://husk321.tistory.com/366)



### vector vs deque

위에서 이야기한대로 vector는 연속적인 공간을 가지지만 deque의 경우에는 **각 블록들이 흩어져 있고 이 흩어진 블록들에 대한 컨트롤 블록을 가지게**됩니다. 

여러 벡터들이 흩어진 형태로 결과적으로 모든 원소들이 연속적인 공간에 있는 것이 아닙니다.



[관련한 필자의 블로그 글](https://husk321.tistory.com/364)