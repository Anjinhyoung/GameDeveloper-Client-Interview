## <algorithm> sort는 어떤 알고리즘인가

간단하게 요약하면 <algorithm> 헤더에 있는 sort 함수는 `인트로 소트(introsort)`를 사용하고 있습니다.

이전에는 퀵 정렬를 사용했다고 하나 퀵 정렬의 고질적인 문제인 최악의 시간복잡도에서는 O(N^2) 시간복잡도가 나온다는 점에서 이 인트로 소트를 채용을 한 것입니다.

인트로 소트는 총 3개의 알고리즘이 섞이게 됩니다.

- 퀵 정렬
- 힙 정렬
- 삽입 정렬

내부의 구현사항을 사용자가 알 수 없게 잘 캡슐화 한 사례이며 배열의 크기가 작다면 삽입 정렬, 크기가 크면 퀵 정렬을 사용하다가 오래 걸린다 판단이 되면 힙 정렬을 사용하는 것으로 구현되어 있습니다.



### 인트로 소트의 자세한 부분

- 배열을 나눈 각 파티션 크기가 최대 깊이 제한인 2LogN을 넘을 가능성이 있다면 힙소트가 됩니다.

- 파티션의 원소가 16개 이하로 작아지면 삽입 정렬이 됩니다.
- 파티션 크기가 제한 미만이고 너무 작지 않다, 즉 16 ~ 2LogN 크기라면 퀵 정렬을 합니다.

삽입 정렬을 넣은 이유는 **삽입 정렬이 작은 배열에 대해서, 정리가 거의 다 된 배열에 대해서 빠른 속도를 가지기 때문**입니다.



여기서 머지 소트를 사용하지 않은 이뉴는 N 만큼의 공간이 추가적으로 필요하기에 사용하지 않습니다.



### 그러면 List의 경우에는?

List와 같은 자료구조는 알고리즘 헤더의 sort 함수로 동작하지 않습니다. 이는 리스트가 랜덤 접근이 안되기 때문이며 List는 자료구조의 멤버 함수 sort를 사용해야 합니다.

그리고 리스트의 내부 정렬 함수는 일반적으로 머지 소트를 사용하게 됩니다. 때문에 시간 복잡도는 O(NlogN)이 됩니다.

